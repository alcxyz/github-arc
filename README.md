# GitOps Repository for Air-Gapped GitHub Actions Runner Cluster

## Overview

This repository contains the Kubernetes manifests and configurations required to manage an air-gapped GitHub Actions Runner cluster using GitOps principles. The cluster runs on k3s deployed on RHEL, and all artifacts (container images, Helm charts, binaries) are sourced from a private ProGet instance.

The core components managed through this repository are:

*   **FluxCD:** The GitOps toolkit synchronizing this repository with the Kubernetes cluster.
*   **Actions Runner Controller (ARC):** Deployed via Helm to manage self-hosted GitHub Actions runners within the cluster.
*   **Secrets:** Sensitive information (API keys, tokens, certificates) managed securely using [SOPS](https://github.com/getsops/sops) with [Age](https://github.com/FiloSottile/age) encryption.
*   **Supporting Configuration:** Flux source definitions (`HelmRepository`) pointing to the private ProGet Helm feed.

## Prerequisites for Interaction

To effectively interact with this repository and the cluster it manages, ensure the following are available:

1.  **Git Client:** For cloning and managing repository changes.
2.  **kubectl:** Configured with access to the target k3s cluster (`KUBECONFIG` environment variable set).
3.  **SOPS CLI:** Installed locally for encrypting and decrypting secrets. Downloadable from the internal ProGet instance.
4.  **Age Private Key:** Access to the `age` private key corresponding to the public key configured in `.sops.yaml`. This is required *only* for viewing or editing secrets locally. **DO NOT COMMIT THE PRIVATE KEY.**
5.  **GitHub Credentials:** Permissions (via PAT or GitHub App) to push changes to this repository.
6.  **ProGet Access:** Network connectivity to the ProGet instance (`<PROGET_BASE_URL>`) from the cluster nodes and potentially from the local workstation for artifact verification.

## Repository Structure

The repository follows a structure compatible with FluxCD conventions:

```
.
├── app/                      # Application-specific manifests
│   └── arc/                  # Manifests related to Actions Runner Controller
│       ├── .sops.yaml        # SOPS configuration (defines encryption rules and public key)
│       ├── helmrepository.yaml # Flux HelmRepository source for ARC chart in ProGet
│       ├── helmrelease.yaml    # Flux HelmRelease definition for ARC deployment
│       ├── secrets/          # Directory containing SOPS-ENCRYPTED Kubernetes Secrets
│       │   ├── 01-proget-docker-creds.yaml
│       │   ├── 02-proget-helm-creds.yaml
│       │   └── 03-arc-github-auth.yaml
│       │   # Add other encrypted secrets here...
│       └── runners/          # (Optional) Manifests for RunnerDeployment/RunnerScaleSet
│           └── my-repo-runners.yaml
│
├── clusters/                 # Cluster-specific Flux configurations (entry points)
│   └── arc-cluster-prod/     # Example: Configuration for the production ARC cluster
│       └── kustomization-arc.yaml # Flux Kustomization managing the 'app/arc' path
│
└── flux-system/              # (Auto-generated by Flux Bootstrap) Contains Flux's own config
    ├── gotk-components.yaml
    ├── gotk-sync.yaml
    └── kustomization.yaml
```

*   **`app/`**: Contains the desired state manifests for applications deployed to the cluster.
*   **`app/arc/`**: Holds all configuration related to the Actions Runner Controller.
    *   **`.sops.yaml`**: Defines which files/fields get encrypted and the public key used. **Crucial for secret management.**
    *   **`secrets/`**: **ONLY ENCRYPTED FILES** should exist here. Contains Kubernetes `Secret` manifests.
    *   **`runners/`**: (If used) Contains `RunnerDeployment` or `RunnerScaleSet` custom resources defining the runners ARC should manage.
*   **`clusters/`**: Contains the top-level Flux `Kustomization` resources that define which paths (like `app/arc`) Flux should manage for a specific cluster.
*   **`flux-system/`**: Managed by Flux itself during the bootstrap process. Generally, avoid manual edits here unless specifically required for Flux configuration.

## Secret Management with SOPS

All sensitive data (API keys, tokens, etc.) stored in this repository **MUST** be encrypted using SOPS with the configured Age key.

*   **Configuration:** The encryption rules and the Age public key are defined in `app/arc/.sops.yaml`.
*   **Viewing Secrets (Requires Private Key):** To view the decrypted content of a secret file locally:
    ```bash
    # Ensure SOPS_AGE_KEY or SOPS_AGE_KEY_FILE environment variable is set,
    # or the key is in the default location (~/.config/sops/age/keys.txt)
    sops -d app/arc/secrets/<secret-file-name>.yaml
    ```
*   **Editing Secrets (Requires Private Key):** To edit an encrypted file (decrypts, opens in `$EDITOR`, re-encrypts on save):
    ```bash
    sops app/arc/secrets/<secret-file-name>.yaml
    ```
*   **Adding a New Secret:**
    1.  Create a standard Kubernetes `Secret` manifest file (e.g., `app/arc/secrets/new-secret.yaml`) with plain text `stringData` or `data` (ensure data values are base64 encoded if using `data`).
    2.  Encrypt the file **in-place** using SOPS:
        ```bash
        # Navigate to the directory containing .sops.yaml (or ensure SOPS can find it)
        sops encrypt --in-place app/arc/secrets/new-secret.yaml
        ```
    3.  Verify the `stringData` or `data` fields now show `ENC[...]`.
    4.  Commit the *encrypted* file.

:warning: **NEVER COMMIT UNENCRYPTED SECRET FILES TO THIS REPOSITORY.** Always verify encryption using `git diff` or by inspecting the file content before committing.

## Making Changes (GitOps Workflow)

1.  **Clone:** Clone this repository locally.
2.  **Branch:** Create a new feature branch for the changes (`git checkout -b my-feature`).
3.  **Modify:** Make the desired changes:
    *   Edit existing manifests.
    *   Add new application manifests or configurations under the appropriate `app/` subdirectory.
    *   Add/edit secrets using the SOPS workflow described above.
4.  **Commit:** Commit the changes with a clear message (`git commit -am "feat: Add new runner deployment"`).
5.  **Push:** Push the branch to GitHub (`git push origin my-feature`).
6.  **Pull Request:** Create a Pull Request for review and merging into the main branch (`main`).
7.  **Sync:** Once merged into `main`, FluxCD will automatically detect the changes (typically within 1-15 minutes, based on configured intervals) and apply them to the cluster.

To trigger a manual reconciliation by Flux immediately:

```bash
# Reconcile the source repository
flux reconcile source git flux-system

# Reconcile the specific Kustomization managing the changed path
flux reconcile kustomization arc-application -n flux-system
```

## Verification and Troubleshooting

*   **Check Flux Sync Status:**
    ```bash
    flux get kustomizations --all-namespaces
    flux get helmreleases --all-namespaces
    flux get sources all --all-namespaces
    ```
*   **Check ARC Pods:**
    ```bash
    kubectl get pods -n arc-systems # Check controller pods
    kubectl get pods -n arc-runners # Check runner pods (or relevant namespace)
    ```
*   **Check Flux Logs:**
    ```bash
    kubectl logs -n flux-system -l app=source-controller
    kubectl logs -n flux-system -l app=kustomize-controller
    kubectl logs -n flux-system -l app=helm-controller
    ```

## Air-Gapped Considerations

*   **Artifact Source:** All container images and Helm charts required by the manifests in this repository **must** be available in the private ProGet instance (`<PROGET_BASE_URL>`).
*   **Updates:** To update components like ARC or the runner images, new versions must first be mirrored/uploaded to ProGet before updating the corresponding image tags or chart versions in the manifests within this repository.
*   **Network:** Ensure the cluster nodes have reliable network access to the ProGet instance. Flux controllers require outbound access to GitHub.

```

**Remember to:**

1.  Replace placeholders like `<PROGET_BASE_URL>`, `<PROGET_API_KEY>` (if mentioned, though ideally not directly in README), `<GITHUB_REPO_NAME>`, specific paths (`clusters/arc-cluster-prod`), and Kustomization names (`arc-application`) with the actual values used in the setup.
2.  Ensure the repository structure described matches the final structure created.